{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Firefox Lockbox for Android documentation!","title":"Introduction"},{"location":"SECURITY/","text":"Mozilla Security Mozilla cares about privacy and security. For more information please see: https://www.mozilla.org/security/ If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com","title":"Mozilla Security #"},{"location":"SECURITY/#mozilla-security","text":"Mozilla cares about privacy and security. For more information please see: https://www.mozilla.org/security/ If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com","title":"Mozilla Security"},{"location":"accessibility/","text":"Accessibility on Lockbox for Android On Lockbox for Android, we implement two forms of automatic testing and encourage developers and testers to use the recommended forms of manual testing to ensure that our application is accessible to every possible user. Automatic Accessibility Lint Checks These are fairly simple static analysis checks. You're probably familiar with warning pop-ups when you have small code style issues; in Lockbox for Android, the build will fail if you do not address these warnings! The most important accessibility warning is the contentDescription warning on images. This warning will appear when the contentDescription attribute-- the text description of the image --has not been set. Espresso Tests AccessibilityChecks.enable() -- This should be added in setup methods for your Espresso tests. When adding new Espresso tests, you may notice failures related to things like tap target size. The automated Espresso accessibility checks occur on every method call in the ViewActions class. Manual Accessibility Testing AccessibilityScanner The Android Accessibility Scanner is a tool used to scan your app's screen to identify potential areas of improvement. If you are using an emulator, download the Accessibility Scanner APK package . Once the APK is downloaded, drag and drop the file into your active emulator and follow onscreen instructions to use the Scanner on your app. If you are using an Android device, download the Android Accessibility Scanner from the Google Play Store on your phone. TalkBack TalkBack is a screen reader that is built into Android devices. This tool can be used to test your application by closing your eyes while attempting to navigate. Instructions on enabling TalkBack on your device: https://support.google.com/accessibility/android/answer/6283677?hl=en&ref_topic=3529932 Changing Text A common accessibility problem arises with users who have changed their font size. Test your app by increasing your device's font size . In addition to font size, be aware of text contrast, color inversion , colorblindness, and color correction.","title":"Accessibility"},{"location":"accessibility/#accessibility-on-lockbox-for-android","text":"On Lockbox for Android, we implement two forms of automatic testing and encourage developers and testers to use the recommended forms of manual testing to ensure that our application is accessible to every possible user.","title":"Accessibility on Lockbox for Android"},{"location":"accessibility/#automatic-accessibility","text":"","title":"Automatic Accessibility"},{"location":"accessibility/#lint-checks","text":"These are fairly simple static analysis checks. You're probably familiar with warning pop-ups when you have small code style issues; in Lockbox for Android, the build will fail if you do not address these warnings! The most important accessibility warning is the contentDescription warning on images. This warning will appear when the contentDescription attribute-- the text description of the image --has not been set.","title":"Lint Checks"},{"location":"accessibility/#espresso-tests","text":"AccessibilityChecks.enable() -- This should be added in setup methods for your Espresso tests. When adding new Espresso tests, you may notice failures related to things like tap target size. The automated Espresso accessibility checks occur on every method call in the ViewActions class.","title":"Espresso Tests"},{"location":"accessibility/#manual-accessibility-testing","text":"","title":"Manual Accessibility Testing"},{"location":"accessibility/#accessibilityscanner","text":"The Android Accessibility Scanner is a tool used to scan your app's screen to identify potential areas of improvement. If you are using an emulator, download the Accessibility Scanner APK package . Once the APK is downloaded, drag and drop the file into your active emulator and follow onscreen instructions to use the Scanner on your app. If you are using an Android device, download the Android Accessibility Scanner from the Google Play Store on your phone.","title":"AccessibilityScanner"},{"location":"accessibility/#talkback","text":"TalkBack is a screen reader that is built into Android devices. This tool can be used to test your application by closing your eyes while attempting to navigate. Instructions on enabling TalkBack on your device: https://support.google.com/accessibility/android/answer/6283677?hl=en&ref_topic=3529932","title":"TalkBack"},{"location":"accessibility/#changing-text","text":"A common accessibility problem arises with users who have changed their font size. Test your app by increasing your device's font size . In addition to font size, be aware of text contrast, color inversion , colorblindness, and color correction.","title":"Changing Text"},{"location":"add_image_assets/","text":"Adding icons/images assets into project Lockbox app uses 2 types of assets for icons/images that are added in the project: Vector Assets and .png raster images. Using vector drawables instead of flat images reduces the size of the APK, the same file is being resized for different screen densities without loss of image quality and also it is easier to maintain one XML file instead of updating multiple raster graphics at various resolutions. However, when adding an image asset to the project, we should take into consideration the following aspects: Vector assets can be added using Vector Asset Studio tool in Android Studio. The tool imports an .svg file (Scalable Vector Graphic) into the project as a vector drawable resource. (The .svg file is available in Zeplin) Simple icons with few details that are intended for small display size (max 200x200dp) should use vector assets. Vector Assets should be added to one the following folders in the application: pp->res->drawable->drawable: for simple icons from Android libraries pp->res->drawable->drawable-v24: for more complex images (e.g. the Lockbox logo) To open Vector Asset Studio tool, go to the appropriate folder in Android View, right click on drawable folder, and select New -> Vector Asset Vector Asset Studio opens. Select Local file, specify the .svg image file path, override the Size and optionally change icon name. Then select Next and Finish More information related to Vector Drawables and Vector Asset Studio can be found here If the image is more complex, has a larger size, or the vector drawable contains attributes that are not supported starting from the minSdk level set in the project (currently minSdk api level is 23)--for example fillType or gradient attributes--we should consider adding flat images for different resolutions. The .png files are also available in Zeplin and they have to be added in res->drawable specific folders: drawable-mdpi , drawable-hdpi , drawable-xhdpi , drawable-xxhdpi . Download the .png files and add each of the images to their corresponding res->drawable folder in Android View If you wish to add both a Vector Asset and .png assets to your project, ensure that all versions of the same image have the same file name (e.g. ic_default_avatar ).","title":"Adding icons/images assets into project"},{"location":"add_image_assets/#adding-iconsimages-assets-into-project","text":"Lockbox app uses 2 types of assets for icons/images that are added in the project: Vector Assets and .png raster images. Using vector drawables instead of flat images reduces the size of the APK, the same file is being resized for different screen densities without loss of image quality and also it is easier to maintain one XML file instead of updating multiple raster graphics at various resolutions. However, when adding an image asset to the project, we should take into consideration the following aspects: Vector assets can be added using Vector Asset Studio tool in Android Studio. The tool imports an .svg file (Scalable Vector Graphic) into the project as a vector drawable resource. (The .svg file is available in Zeplin) Simple icons with few details that are intended for small display size (max 200x200dp) should use vector assets. Vector Assets should be added to one the following folders in the application: pp->res->drawable->drawable: for simple icons from Android libraries pp->res->drawable->drawable-v24: for more complex images (e.g. the Lockbox logo) To open Vector Asset Studio tool, go to the appropriate folder in Android View, right click on drawable folder, and select New -> Vector Asset Vector Asset Studio opens. Select Local file, specify the .svg image file path, override the Size and optionally change icon name. Then select Next and Finish More information related to Vector Drawables and Vector Asset Studio can be found here If the image is more complex, has a larger size, or the vector drawable contains attributes that are not supported starting from the minSdk level set in the project (currently minSdk api level is 23)--for example fillType or gradient attributes--we should consider adding flat images for different resolutions. The .png files are also available in Zeplin and they have to be added in res->drawable specific folders: drawable-mdpi , drawable-hdpi , drawable-xhdpi , drawable-xxhdpi . Download the .png files and add each of the images to their corresponding res->drawable folder in Android View If you wish to add both a Vector Asset and .png assets to your project, ensure that all versions of the same image have the same file name (e.g. ic_default_avatar ).","title":"Adding icons/images assets into project"},{"location":"contributing/","text":"Contributing Thank you for considering and taking the time to contribute! The following are guidelines for contributing to this project. Code of Conduct This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the Mozilla Community Participation Guidelines and Developer Etiquette Guidelines . How to Get Started Please refer to installation and build instructions in the documentation . LeakCanary We use LeakCanary to monitor memory leaks in Debug builds of the Lockbox Android application. Please read the documentation and pay attention to warnings while debugging the application! How to Report Bugs Please open a new issue in the GitHub repository with steps to reproduce the problem you're experiencing. Be sure to include as much information including screenshots, text output, and both your expected and actual results. If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com How to Request Enhancements First, please refer to the applicable GitHub repository and search the repository's GitHub issues to make sure your idea has not been (or is not still) considered. Then, please create a new issue in the GitHub repository describing your enhancement. Be sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile. Please keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented. How to Contribute Code Before you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of good first issues and find something that sounds interesting. If there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to file an issue first. Once you have a patch ready: Make sure all tests are passing and try to add tests for the code you've written. Submit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.","title":"Contributing"},{"location":"contributing/#contributing","text":"Thank you for considering and taking the time to contribute! The following are guidelines for contributing to this project.","title":"Contributing"},{"location":"contributing/#code-of-conduct","text":"This repository is governed by Mozilla's code of conduct and etiquette guidelines. For more details please see the Mozilla Community Participation Guidelines and Developer Etiquette Guidelines .","title":"Code of Conduct"},{"location":"contributing/#how-to-get-started","text":"Please refer to installation and build instructions in the documentation .","title":"How to Get Started"},{"location":"contributing/#leakcanary","text":"We use LeakCanary to monitor memory leaks in Debug builds of the Lockbox Android application. Please read the documentation and pay attention to warnings while debugging the application!","title":"LeakCanary"},{"location":"contributing/#how-to-report-bugs","text":"Please open a new issue in the GitHub repository with steps to reproduce the problem you're experiencing. Be sure to include as much information including screenshots, text output, and both your expected and actual results. If you believe that you've found a security vulnerability, please report it by sending email to the addresses: security@mozilla.org and lockbox-dev@mozilla.com","title":"How to Report Bugs"},{"location":"contributing/#how-to-request-enhancements","text":"First, please refer to the applicable GitHub repository and search the repository's GitHub issues to make sure your idea has not been (or is not still) considered. Then, please create a new issue in the GitHub repository describing your enhancement. Be sure to include as much detail as possible including step-by-step descriptions, specific examples, screenshots or mockups, and reasoning for why the enhancement might be worthwhile. Please keep in mind, by opening an issue we provide no guarantee the enhancement will be implemented.","title":"How to Request Enhancements"},{"location":"contributing/#how-to-contribute-code","text":"Before you get started writing code, be sure what you plan to work on is something we'll be able to accept. The easiest way is to look through out list of good first issues and find something that sounds interesting. If there's something else you'd like to work on, just add a comment in the relevant issue and we'll be happy to discuss your plans. If you have an idea that doesn't have an issue at all, be sure to file an issue first. Once you have a patch ready: Make sure all tests are passing and try to add tests for the code you've written. Submit a pull request! From there, we'll guide you through the review process to the eventual landing of your code. We aim to respond to all review requests within two business days.","title":"How to Contribute Code"},{"location":"install/","text":"Required Libraries Our linting configuration requires you to have an up-to-date installation of ktlint Steps to Run / Build Install the latest Android Studio Clone the repository Open the project in Android Studio Gradle Sync & build/run the project Testing The tests can be run from Android Studio or from the command line: ./gradlew testDebug Code coverage Local code coverage reports can be generated from Android Studio or from the command line: ./gradlew -Pcoverage jacocoDebugTestReport The command line reports can be found at app/build/reports/jacoco/jacocoDebugTestReport/html/index.html . N.B.: each method uses a different reporter and will provide different results. They both tend to miss things: it's often best to test your code using both. The project's official code coverage rating can be found on codecov.io , which uses the results from jacoco (i.e. the command line).","title":"Build and Install"},{"location":"install/#required-libraries","text":"Our linting configuration requires you to have an up-to-date installation of ktlint","title":"Required Libraries"},{"location":"install/#steps-to-run-build","text":"Install the latest Android Studio Clone the repository Open the project in Android Studio Gradle Sync & build/run the project","title":"Steps to Run / Build"},{"location":"install/#testing","text":"The tests can be run from Android Studio or from the command line: ./gradlew testDebug","title":"Testing"},{"location":"install/#code-coverage","text":"Local code coverage reports can be generated from Android Studio or from the command line: ./gradlew -Pcoverage jacocoDebugTestReport The command line reports can be found at app/build/reports/jacoco/jacocoDebugTestReport/html/index.html . N.B.: each method uses a different reporter and will provide different results. They both tend to miss things: it's often best to test your code using both. The project's official code coverage rating can be found on codecov.io , which uses the results from jacoco (i.e. the command line).","title":"Code coverage"},{"location":"metrics/","text":"Firefox Lockbox for Android Metrics Plan Last Updated: Feb 4, 2019 Analysis Collection List of Implemented Events Adjust SDK References This is the metrics collection plan for the Lockbox Android app. It documents all events that are currently collected through telemetry. It will be updated periodically to reflect all new and planned data collection. A similar document for the Lockbox for iOS app can be found here . Analysis Data collection is done solely for the purpose of product development, improvement and maintenance. We analyze the data described in this doc primarily with the purpose of (dis)confirming the following hypothesis: If Firefox users have access to their browser-saved passwords on their mobile device but outside of the mobile browser, then they will use those passwords to log into both websites (via a browser; Firefox or otherwise) and stand-alone apps. We will know this to be true when the most frequent actions taken in the app are revealing, copying, or autofilling of credentials. In service to validating the above hypothesis, we plan on answering these specific questions, given the data we collect (see List of Implemented Events ): Note that when we refer to retrieval of \"credentials\", we mean access to usernames, passwords, or both Are users using Lockbox to retrieve credentials? For different intervals of time (e.g. day, week, month), what is: The average rate with which a user retrieves a credential or reveals a password The distribution of above rates across all users How often do users access Lockbox credentials via autofill, versus directly through the credential list provided by the app? Once downloaded, do users continue to use the app? (i.e., how well are they retained?) We will count a user as retained in a given time interval if they perform one of the following actions: Display the credential list Tap a credential in the credential list Copy a credential to the clipboard Reveal a password Autofill a credential stored in Lockbox into another app Tap the URI associated with a credential (to open it in an app or browser) Since they can be performed automatically, we will not count a user as retained if they only perform the following actions (in absence of any in the list above): Unlock their credentials Sync their credentials from the Firefox desktop browser Does requiring a Firefox Account constitute a roadblock to adoption? What proportion of new Lockbox users are pre-existing Firefox Account users? What proportion of users start the Account sign-in process but never complete it? Does adoption of Lockbox lead to adoption of Firefox Mobile browsers (e.g. Focus)? Do users set the default browser in Lockbox to be a Firefox browser? In addition to answering the above questions that directly concern actions in the app, we will also analyze telemetry emitted from the password manager that exists in the the Firefox desktop browser. These analyses will primarily examine whether users of Lockbox start active curation of their credentials in the desktop browser (Lockbox users will not be able to edit credentials directly from the app). Collection Note: There is currently a new Mozilla mobile telemetry SDK under development, however it will not ship prior to the Lockbox for Android app. Once the new SDK ships we will evaluate whether or not to tear out the old implementation and replace it with the new SDK. Data is collected using this library: https://github.com/mozilla-mobile/android-components/blob/master/components/service/telemetry/README.md We submit two ping types, both of which are implemented by the component above. First is the core ping , which contains information about the Android version, architecture, etc of the device Lockbox has been installed on: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/core-ping.html The second is the event ping which allows us to record event telemetry: https://github.com/mozilla-mobile/focus-android/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service See this for the kotlin source code that Firefox Focus uses to define its telemetry events. Every event must contain category , method and object fields, and may optionally contain value and extra fields as well. Finally, the appName metadata sent with each ping should always be Lockbox . See here for more information on event schemas: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#public-js-api List of Implemented Events When the app starts up: category : action method : startup object : app value : null extras : null When locking/unlocking/accessing the datastore: category : action method : lock, unlock, reset, sync, update_credentials, touch object : datastore value : null extras : null Events that fire during the setup process: category : action method : show object : login_welcome, login_fxa, login_onboarding_confirmation, login_learn_more value : null extras : null When the main item list is shown to the user: category : action method : show object : entry_list value : null extras : null When a user shows the details of an item in the entry list: category : action method : show object : entry_detail value : null extras : null When a user taps one of the copy buttons available after being shown entry details: category : action method : tap object : entry_copy_username_button, entry_copy_password_button value : null extras : null When a user taps to reveal a password: category : action method : tap object : reveal_password value : null extras : null When one of the settings pages is shown to the user: category : action method : show object : settings_list, settings_autolock, settings_account, settings_faq, settings_provide_feedback value : null extras : null When a user changes something on the settings page: category : action method : setting_changed object : settings_autolock_time, settings_reset, settings_fingerprint, settings_fingerprint_pending_auth, settings_item_list_order, value : whatever the value of each of the above was changed to, for example 60 in the case of settings_autolock_time extras : null When the app enters the background or foreground: category : action method : background, foreground object : app value : null extras : null When a user taps on the search box to filter the credential list: category : action method : tap object : filter value : null extras : null When a user taps on a link to open a webpage in their browser: category : action method : tap object : open_in_browser value : null extras : null When a user interacts with the autofill functionality category : action method : autofill_error (there was an error when attempting to fill a form), autofill_multiple (the autofill API returned a list possible credentials to fill a form), autofill_single (a credential was selected from the list of possible credentials to fill a form), autofill_filter (the user filtered a returned list of autofill credentials), autofill_locked (the datastore was locked when a form triggered the autofill API), autofill_cancel (the user cancelled form autofill), background (when the autofill service is backgrounded, doesn't necessarily involve user-facing UX), foreground (always when the autofill service is foregrounded, doesn't necessarily involve user-facing UX) object : autofill value : null extras : null Adjust SDK The app also includes a version of the adjust SDK . Mozilla uses this software to keep track of the number of installations of the Lockbox app, as well the number of new Firefox Accounts registered through the app. References Library used to collect and send telemetry on Android Description of the \"Core\" ping Description of the \"Focus Event\" Ping Description of Event Schemas in General","title":"Telemetry and Metrics"},{"location":"metrics/#firefox-lockbox-for-android-metrics-plan","text":"Last Updated: Feb 4, 2019 Analysis Collection List of Implemented Events Adjust SDK References This is the metrics collection plan for the Lockbox Android app. It documents all events that are currently collected through telemetry. It will be updated periodically to reflect all new and planned data collection. A similar document for the Lockbox for iOS app can be found here .","title":"Firefox Lockbox for Android Metrics Plan"},{"location":"metrics/#analysis","text":"Data collection is done solely for the purpose of product development, improvement and maintenance. We analyze the data described in this doc primarily with the purpose of (dis)confirming the following hypothesis: If Firefox users have access to their browser-saved passwords on their mobile device but outside of the mobile browser, then they will use those passwords to log into both websites (via a browser; Firefox or otherwise) and stand-alone apps. We will know this to be true when the most frequent actions taken in the app are revealing, copying, or autofilling of credentials. In service to validating the above hypothesis, we plan on answering these specific questions, given the data we collect (see List of Implemented Events ): Note that when we refer to retrieval of \"credentials\", we mean access to usernames, passwords, or both Are users using Lockbox to retrieve credentials? For different intervals of time (e.g. day, week, month), what is: The average rate with which a user retrieves a credential or reveals a password The distribution of above rates across all users How often do users access Lockbox credentials via autofill, versus directly through the credential list provided by the app? Once downloaded, do users continue to use the app? (i.e., how well are they retained?) We will count a user as retained in a given time interval if they perform one of the following actions: Display the credential list Tap a credential in the credential list Copy a credential to the clipboard Reveal a password Autofill a credential stored in Lockbox into another app Tap the URI associated with a credential (to open it in an app or browser) Since they can be performed automatically, we will not count a user as retained if they only perform the following actions (in absence of any in the list above): Unlock their credentials Sync their credentials from the Firefox desktop browser Does requiring a Firefox Account constitute a roadblock to adoption? What proportion of new Lockbox users are pre-existing Firefox Account users? What proportion of users start the Account sign-in process but never complete it? Does adoption of Lockbox lead to adoption of Firefox Mobile browsers (e.g. Focus)? Do users set the default browser in Lockbox to be a Firefox browser? In addition to answering the above questions that directly concern actions in the app, we will also analyze telemetry emitted from the password manager that exists in the the Firefox desktop browser. These analyses will primarily examine whether users of Lockbox start active curation of their credentials in the desktop browser (Lockbox users will not be able to edit credentials directly from the app).","title":"Analysis"},{"location":"metrics/#collection","text":"Note: There is currently a new Mozilla mobile telemetry SDK under development, however it will not ship prior to the Lockbox for Android app. Once the new SDK ships we will evaluate whether or not to tear out the old implementation and replace it with the new SDK. Data is collected using this library: https://github.com/mozilla-mobile/android-components/blob/master/components/service/telemetry/README.md We submit two ping types, both of which are implemented by the component above. First is the core ping , which contains information about the Android version, architecture, etc of the device Lockbox has been installed on: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/data/core-ping.html The second is the event ping which allows us to record event telemetry: https://github.com/mozilla-mobile/focus-android/wiki/Event-Tracking-with-Mozilla%27s-Telemetry-Service See this for the kotlin source code that Firefox Focus uses to define its telemetry events. Every event must contain category , method and object fields, and may optionally contain value and extra fields as well. Finally, the appName metadata sent with each ping should always be Lockbox . See here for more information on event schemas: https://firefox-source-docs.mozilla.org/toolkit/components/telemetry/telemetry/collection/events.html#public-js-api","title":"Collection"},{"location":"metrics/#list-of-implemented-events","text":"When the app starts up: category : action method : startup object : app value : null extras : null When locking/unlocking/accessing the datastore: category : action method : lock, unlock, reset, sync, update_credentials, touch object : datastore value : null extras : null Events that fire during the setup process: category : action method : show object : login_welcome, login_fxa, login_onboarding_confirmation, login_learn_more value : null extras : null When the main item list is shown to the user: category : action method : show object : entry_list value : null extras : null When a user shows the details of an item in the entry list: category : action method : show object : entry_detail value : null extras : null When a user taps one of the copy buttons available after being shown entry details: category : action method : tap object : entry_copy_username_button, entry_copy_password_button value : null extras : null When a user taps to reveal a password: category : action method : tap object : reveal_password value : null extras : null When one of the settings pages is shown to the user: category : action method : show object : settings_list, settings_autolock, settings_account, settings_faq, settings_provide_feedback value : null extras : null When a user changes something on the settings page: category : action method : setting_changed object : settings_autolock_time, settings_reset, settings_fingerprint, settings_fingerprint_pending_auth, settings_item_list_order, value : whatever the value of each of the above was changed to, for example 60 in the case of settings_autolock_time extras : null When the app enters the background or foreground: category : action method : background, foreground object : app value : null extras : null When a user taps on the search box to filter the credential list: category : action method : tap object : filter value : null extras : null When a user taps on a link to open a webpage in their browser: category : action method : tap object : open_in_browser value : null extras : null When a user interacts with the autofill functionality category : action method : autofill_error (there was an error when attempting to fill a form), autofill_multiple (the autofill API returned a list possible credentials to fill a form), autofill_single (a credential was selected from the list of possible credentials to fill a form), autofill_filter (the user filtered a returned list of autofill credentials), autofill_locked (the datastore was locked when a form triggered the autofill API), autofill_cancel (the user cancelled form autofill), background (when the autofill service is backgrounded, doesn't necessarily involve user-facing UX), foreground (always when the autofill service is foregrounded, doesn't necessarily involve user-facing UX) object : autofill value : null extras : null","title":"List of Implemented Events"},{"location":"metrics/#adjust-sdk","text":"The app also includes a version of the adjust SDK . Mozilla uses this software to keep track of the number of installations of the Lockbox app, as well the number of new Firefox Accounts registered through the app.","title":"Adjust SDK"},{"location":"metrics/#references","text":"Library used to collect and send telemetry on Android Description of the \"Core\" ping Description of the \"Focus Event\" Ping Description of Event Schemas in General","title":"References"},{"location":"pull_request_template/","text":"Fixes #??? ( Required : this reference (one or many) will be closed upon merge. Ideally it has the acceptance criteria and designs for features or fixes related to the work in this Pull Request.) Connected to #??? (Optional: other issues or pull requests related to this, but merging should not close it) Testing and Review Notes ( Required : steps to take to confirm this works as expected or other guidance for code, UX, and any other reviewers) Screenshots or Videos (Optional: to clearly demonstrate the feature or fix to help with testing and reviews) To Do add \u201cWIP\u201d to the PR title if pushing up but not complete nor ready for review [ ] double check the original issue to confirm it is fully satisfied [ ] add testing notes and screenshots in PR description to help guide reviewers [ ] add unit tests optional: consider adding instrumentation (integration/UI) tests consider running this branch in a debug simulator and check for memory leak notifications or any warnings [ ] request the \"UX\" team perform a design review (if/when applicable) [ ] make sure CI builds are passing (e.g.: fix lint and other errors) [ ] check on the accessibility of any added UI","title":"Pull request template"},{"location":"pull_request_template/#testing-and-review-notes","text":"( Required : steps to take to confirm this works as expected or other guidance for code, UX, and any other reviewers)","title":"Testing and Review Notes"},{"location":"pull_request_template/#screenshots-or-videos","text":"(Optional: to clearly demonstrate the feature or fix to help with testing and reviews)","title":"Screenshots or Videos"},{"location":"pull_request_template/#to-do","text":"add \u201cWIP\u201d to the PR title if pushing up but not complete nor ready for review [ ] double check the original issue to confirm it is fully satisfied [ ] add testing notes and screenshots in PR description to help guide reviewers [ ] add unit tests optional: consider adding instrumentation (integration/UI) tests consider running this branch in a debug simulator and check for memory leak notifications or any warnings [ ] request the \"UX\" team perform a design review (if/when applicable) [ ] make sure CI builds are passing (e.g.: fix lint and other errors) [ ] check on the accessibility of any added UI","title":"To Do"},{"location":"release-notes/","text":"Release Notes 1.0.2 (Build 3417) First Alpha/Beta build with dependency updates, paving way for more crash reporting and fixes coming soon. update constraintlayout dependency (#578) fix race condition in LocketPresenterTest (#573) update more dependencies (#572) add Sentry to log errors and crashes (#588) update UI tests (#590) enable R8 and byte-level optimizations (#594) 1.0.1 (Build 3320) Date: 2019-04-04 Release Candidate improve navigation and routing for stability (#499) make finger print auth action flatter (#529) fix font in spinner list (#540) add nullsafe operations on FingerprintManager to prevent crashes (#546) change network connection checks (#518) fix error text alignment (#538) fix mismatching monster on unlock screen (#553) improve autofill behavior after backgrounding (#502) add app bar shadow (#566) add build number on settings screen (#552) add title to sign in screen (#569) autolock on device restart (#568) merge route presenters (#539) 1.0.1 (Build 3307) Date: 2019-04-01 Third internal test build for post-launch point release. improve navigation and routing for stability (#499) make finger print auth action flatter (#529) fix font in spinner list (#540) add nullsafe operations on FingerprintManager to prevent crashes (#546) change network connection checks (#518) fix error text alignment (#538) fix mismatching monster on unlock screen (#553) improve autofill behavior after backgrounding (#502) add app bar shadow (#566) add build number on settings screen (#552) add title to sign in screen (#569) autolock on device restart (#568) 1.0.1 (Build 3264) Date: 2019-04-01 Second internal test build for post-launch point release. improve navigation and routing for stability (#499) make finger print auth action flatter (#529) fix font in spinner list (#540) add nullsafe operations on FingerprintManager to prevent crashes (#546) change network connection checks (#518) fix error text alignment (#538) fix mismatching monster on unlock screen (#553) improve autofill behavior after backgrounding (#502) add app bar shadow (#566) 1.0.1 (Build 3190) Date: 2019-03-26 First internal test build for post-launch point release. improve navigation and routing for stability (#499) make finger print auth action flatter (#529) 1.0.0 (Build 3171) Date: 2019-03-26 Introducing Firefox Lockbox for Android! Minor change since Build 3137: add error handler to filtering to prevent crashes on autofill (#526) 1.0.0 (Build 3137) Date: 2019-03-21 Minor changes since Release Candidate: Fix Adjust integration (#521) Add more autofill telemetry actions (#522) use blocking operators rather than inline checks (#506) only update lock status after updating list (#505) 1.0.0 (Build 3024) Date: 2019-03-14 Release Candidate moved some dependencies into our codebase (#491) fixed crash on entries with no username (#496) fixed bug in onboarding screen (#495) added telemetry to autofill events (#498) added Adjust (#497) 1.0 (Build 2955) Date: 2019-03-08 Fourth internal Alpha release on Play Store. Changes include: more telemetry events (#439) onboarding instructions if no device security set (#438) handling automatic locking if no device security set (#456) automatically launch biometrics prompt when returning from background (#428) improvements to networking warning error (#458) added handling for empty username entries (#451) autofill infrastructure and UI improvements (#470 #471 #474 #475 #487) 1.0 (Build 2599) Date: 2019-02-19 Third internal Alpha release on Play Store. Changes include: added autofill support to webpages (#404) added launch hint icon next to hostname (#399) added support to enable autofill from settings screen (#417) added the public suffix list to be less permissive on fill matching (#425) added biometric unlock onboarding flow (#396) added confirmation screen during onboarding (#432) added authentication during autofill when app is locked (#413) made entire username and password rows tappable to copy (#400) added FAQ links and instructions (#423) added onboarding screen to enable autofill (#429) improved initialization, autolock, and autofill states (#437, #446) 1.0 (Build 2247) Date: 2019-01-26 Second internal Alpha release on Play Store. Changes include: updates to android-components dependencies (#358, #377) smaller app size due to less redundant dependency inclusion (#353) stability and fixes for locking and unlocking (#347) initial credential provider / autofill infrastructure (#351) fix for support text box overlapping setting toggle (#370) added copy notification (toast) styling (#374) autofill added to app username/password forms (#372) more stability around locking and unlocking and routing (#349) improved notifications and handling when offline (#286) add placeholder splash screen so no flash of \"welcome\" screen (#391) add \"no saved entries\" screen so you know why its empty (#397) 1.0 (Build 2050) Date: 2019-01-08 First internal Alpha release on Play Store","title":"Release Notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#102-build-3417","text":"First Alpha/Beta build with dependency updates, paving way for more crash reporting and fixes coming soon. update constraintlayout dependency (#578) fix race condition in LocketPresenterTest (#573) update more dependencies (#572) add Sentry to log errors and crashes (#588) update UI tests (#590) enable R8 and byte-level optimizations (#594)","title":"1.0.2 (Build 3417)"},{"location":"release-notes/#101-build-3320","text":"Date: 2019-04-04 Release Candidate improve navigation and routing for stability (#499) make finger print auth action flatter (#529) fix font in spinner list (#540) add nullsafe operations on FingerprintManager to prevent crashes (#546) change network connection checks (#518) fix error text alignment (#538) fix mismatching monster on unlock screen (#553) improve autofill behavior after backgrounding (#502) add app bar shadow (#566) add build number on settings screen (#552) add title to sign in screen (#569) autolock on device restart (#568) merge route presenters (#539)","title":"1.0.1 (Build 3320)"},{"location":"release-notes/#101-build-3307","text":"Date: 2019-04-01 Third internal test build for post-launch point release. improve navigation and routing for stability (#499) make finger print auth action flatter (#529) fix font in spinner list (#540) add nullsafe operations on FingerprintManager to prevent crashes (#546) change network connection checks (#518) fix error text alignment (#538) fix mismatching monster on unlock screen (#553) improve autofill behavior after backgrounding (#502) add app bar shadow (#566) add build number on settings screen (#552) add title to sign in screen (#569) autolock on device restart (#568)","title":"1.0.1 (Build 3307)"},{"location":"release-notes/#101-build-3264","text":"Date: 2019-04-01 Second internal test build for post-launch point release. improve navigation and routing for stability (#499) make finger print auth action flatter (#529) fix font in spinner list (#540) add nullsafe operations on FingerprintManager to prevent crashes (#546) change network connection checks (#518) fix error text alignment (#538) fix mismatching monster on unlock screen (#553) improve autofill behavior after backgrounding (#502) add app bar shadow (#566)","title":"1.0.1 (Build 3264)"},{"location":"release-notes/#101-build-3190","text":"Date: 2019-03-26 First internal test build for post-launch point release. improve navigation and routing for stability (#499) make finger print auth action flatter (#529)","title":"1.0.1 (Build 3190)"},{"location":"release-notes/#100-build-3171","text":"Date: 2019-03-26 Introducing Firefox Lockbox for Android! Minor change since Build 3137: add error handler to filtering to prevent crashes on autofill (#526)","title":"1.0.0 (Build 3171)"},{"location":"release-notes/#100-build-3137","text":"Date: 2019-03-21 Minor changes since Release Candidate: Fix Adjust integration (#521) Add more autofill telemetry actions (#522) use blocking operators rather than inline checks (#506) only update lock status after updating list (#505)","title":"1.0.0 (Build 3137)"},{"location":"release-notes/#100-build-3024","text":"Date: 2019-03-14 Release Candidate moved some dependencies into our codebase (#491) fixed crash on entries with no username (#496) fixed bug in onboarding screen (#495) added telemetry to autofill events (#498) added Adjust (#497)","title":"1.0.0 (Build 3024)"},{"location":"release-notes/#10-build-2955","text":"Date: 2019-03-08 Fourth internal Alpha release on Play Store. Changes include: more telemetry events (#439) onboarding instructions if no device security set (#438) handling automatic locking if no device security set (#456) automatically launch biometrics prompt when returning from background (#428) improvements to networking warning error (#458) added handling for empty username entries (#451) autofill infrastructure and UI improvements (#470 #471 #474 #475 #487)","title":"1.0 (Build 2955)"},{"location":"release-notes/#10-build-2599","text":"Date: 2019-02-19 Third internal Alpha release on Play Store. Changes include: added autofill support to webpages (#404) added launch hint icon next to hostname (#399) added support to enable autofill from settings screen (#417) added the public suffix list to be less permissive on fill matching (#425) added biometric unlock onboarding flow (#396) added confirmation screen during onboarding (#432) added authentication during autofill when app is locked (#413) made entire username and password rows tappable to copy (#400) added FAQ links and instructions (#423) added onboarding screen to enable autofill (#429) improved initialization, autolock, and autofill states (#437, #446)","title":"1.0 (Build 2599)"},{"location":"release-notes/#10-build-2247","text":"Date: 2019-01-26 Second internal Alpha release on Play Store. Changes include: updates to android-components dependencies (#358, #377) smaller app size due to less redundant dependency inclusion (#353) stability and fixes for locking and unlocking (#347) initial credential provider / autofill infrastructure (#351) fix for support text box overlapping setting toggle (#370) added copy notification (toast) styling (#374) autofill added to app username/password forms (#372) more stability around locking and unlocking and routing (#349) improved notifications and handling when offline (#286) add placeholder splash screen so no flash of \"welcome\" screen (#391) add \"no saved entries\" screen so you know why its empty (#397)","title":"1.0 (Build 2247)"},{"location":"release-notes/#10-build-2050","text":"Date: 2019-01-08 First internal Alpha release on Play Store","title":"1.0 (Build 2050)"},{"location":"releases/","text":"Release Instructions Some assumptions: master is the default branch and is production-ready non-'master' and non-'production' branches run the \"primary\" workflow which signs a \"Debug\" variant though, users with access can manually \"Start\" a \"deploy\" build against a branch from the bitrise UI commits made to master and production are built and pass in bitrise the \"deploy\" workflow in bitrise runs and signs a \"Release\" variant APK bitrise will test, build, and sign the APK for every build on every branch production is our public release branch and may not match master ideally, production will perfectly reproduce master but if master is in an un-releasable state, we cherry-pick commits to this branch this is an exception rather than the preferred maintenance method no automated uploads to Google Play Console occur, manual artifact uploads (from bitrise's signed Release artifacts) are required for internal, closed, open, and production releases Play Store has Internal (core team, email-restricted), Alpha (closed, email-restricted), and Production (everyone!) release channels configured currently, no plans exist for \"external\" testers nor \"Open\" release channels in the future we may create an open Beta testing channel to allow anyone outside of Mozilla to help us test in-progress work Distributing Builds through bitrise (primary = branch, deploy = master) all commits on all branches and pull requests are automatically built Push to the git branch available on GitHub.com and open a pull request Open bitrise from a mobile device and browse to the build bitrise access is currently private and email-restricted Preparing a Release (for Internal, Alpha, or Production via Play Store) Update the release notes under docs/release-notes.md create a pull request to collaborate and get approval determine the next build number and include it in release notes merge the release notes to master branch this will result in a release build matching the build number provided Create and merge a pull request from master to production so it tracks the release https://github.com/mozilla-lockbox/lockbox-android/compare/production...master Create a tag from production matching the format: major.minor.patch.build for example: 1.2.1399 is major version 1.2, bitrise build 1399 for example: 1.3.1.1624 is major version 1.3 with 1 patch release, (bitrise) build 1624 git tag -a -s 1.3.1.1624 -m \"1.3.1 (Build 1624)\" push the tag to GitHub and create a corresponding \"Release\" on GitHub.com copy the release notes to the \"Release\" on GitHub download the -signed.apk from bitrise and attach it to the Release on GitHub open the -signed.apk and confirm release build does not allow screenshots and does not expose the contents of the app in the switcher Upload the -signed.apk (from bitrise) to the Play Console : browse to \"Release Management\" > \"App Releases\" > \"Internal test track\" > \"Manage\" \"Create Release\" and upload the signed APK, set the version to match the tag (for example: 1.2.1339 ) then \"Review\" and the build will be immediately available to the core team Continue the \"Distributing...\" instructions In Case of Emergency (Release) similar to above, but requires explicit cherry-pick commits on production branch when master branch is not in a release-able state Merge the emergency changes or fixes or features to default master branch as usual Update the release notes Create and merge a pull request up to and including the last release-able commit on master to production Then git cherry-pick each additional commit from master to be included in the release thus skipping or avoiding the non-release-able commits Push the resulting production branch to GitHub.com Create a tag from production matching the format: major.minor.patch.build for example: git tag -a -s 1.3.1.1624 -m \"1.3.1 (Build 1624)\" Push the tag to GitHub and create a corresponding \"Release\" on GitHub.com copy the release notes to the \"Release\" on GitHub Browse to bitrise and find the desired production branch build to distribute download the .signed-apk and attach it to the Release on GitHub open the -signed.apk and confirm release build does not allow screenshots and does not expose the contents of the app in the switcher Upload the -signed.apk (from bitrise) to the Play Console : browse to \"Release Management\" > \"App Releases\" > \"Internal test track\" > \"Manage\" \"Create Release\" and upload the signed APK, set the version to match the tag (for example: 1.2.1339 ) then \"Review\" and the build will be immediately available to the core team Continue the \"Distributing...\" instructions Distributing Builds through Play Store (Internal, Alpha) all builds must be manually uploaded from bitrise to Play Store Console as an artifact aka \"New Release\" in the \"Preparing\" instructions above Browse to App Releases in Play Console Browse to the \"Internal test track\" (this release should already be uploaded and available to the core Lockbox team) Promote the release to the (internal still) Alpha channel using the \"Promote to Alpha\" button, complete the questions Distributing through the App Store (Production) Contact release management... NOTE: brand new apps may take 1 or more hours to appear in the Play Store whereas existing app (updates) can appear within minutes. Schedule accordingly! Updating the version Once a version has been merged or released, the major app version should be increased Update the versionName value (and versionCode if applicable) in app/build.gradle Also update the value in the list_cell_setting_appversion.xml layout to the exact same version","title":"Release Instructions"},{"location":"releases/#release-instructions","text":"Some assumptions: master is the default branch and is production-ready non-'master' and non-'production' branches run the \"primary\" workflow which signs a \"Debug\" variant though, users with access can manually \"Start\" a \"deploy\" build against a branch from the bitrise UI commits made to master and production are built and pass in bitrise the \"deploy\" workflow in bitrise runs and signs a \"Release\" variant APK bitrise will test, build, and sign the APK for every build on every branch production is our public release branch and may not match master ideally, production will perfectly reproduce master but if master is in an un-releasable state, we cherry-pick commits to this branch this is an exception rather than the preferred maintenance method no automated uploads to Google Play Console occur, manual artifact uploads (from bitrise's signed Release artifacts) are required for internal, closed, open, and production releases Play Store has Internal (core team, email-restricted), Alpha (closed, email-restricted), and Production (everyone!) release channels configured currently, no plans exist for \"external\" testers nor \"Open\" release channels in the future we may create an open Beta testing channel to allow anyone outside of Mozilla to help us test in-progress work","title":"Release Instructions"},{"location":"releases/#distributing-builds-through-bitrise-primary-branch-deploy-master","text":"all commits on all branches and pull requests are automatically built Push to the git branch available on GitHub.com and open a pull request Open bitrise from a mobile device and browse to the build bitrise access is currently private and email-restricted","title":"Distributing Builds through bitrise (primary = branch, deploy = master)"},{"location":"releases/#preparing-a-release-for-internal-alpha-or-production-via-play-store","text":"Update the release notes under docs/release-notes.md create a pull request to collaborate and get approval determine the next build number and include it in release notes merge the release notes to master branch this will result in a release build matching the build number provided Create and merge a pull request from master to production so it tracks the release https://github.com/mozilla-lockbox/lockbox-android/compare/production...master Create a tag from production matching the format: major.minor.patch.build for example: 1.2.1399 is major version 1.2, bitrise build 1399 for example: 1.3.1.1624 is major version 1.3 with 1 patch release, (bitrise) build 1624 git tag -a -s 1.3.1.1624 -m \"1.3.1 (Build 1624)\" push the tag to GitHub and create a corresponding \"Release\" on GitHub.com copy the release notes to the \"Release\" on GitHub download the -signed.apk from bitrise and attach it to the Release on GitHub open the -signed.apk and confirm release build does not allow screenshots and does not expose the contents of the app in the switcher Upload the -signed.apk (from bitrise) to the Play Console : browse to \"Release Management\" > \"App Releases\" > \"Internal test track\" > \"Manage\" \"Create Release\" and upload the signed APK, set the version to match the tag (for example: 1.2.1339 ) then \"Review\" and the build will be immediately available to the core team Continue the \"Distributing...\" instructions","title":"Preparing a Release (for Internal, Alpha, or Production via Play Store)"},{"location":"releases/#in-case-of-emergency-release","text":"similar to above, but requires explicit cherry-pick commits on production branch when master branch is not in a release-able state Merge the emergency changes or fixes or features to default master branch as usual Update the release notes Create and merge a pull request up to and including the last release-able commit on master to production Then git cherry-pick each additional commit from master to be included in the release thus skipping or avoiding the non-release-able commits Push the resulting production branch to GitHub.com Create a tag from production matching the format: major.minor.patch.build for example: git tag -a -s 1.3.1.1624 -m \"1.3.1 (Build 1624)\" Push the tag to GitHub and create a corresponding \"Release\" on GitHub.com copy the release notes to the \"Release\" on GitHub Browse to bitrise and find the desired production branch build to distribute download the .signed-apk and attach it to the Release on GitHub open the -signed.apk and confirm release build does not allow screenshots and does not expose the contents of the app in the switcher Upload the -signed.apk (from bitrise) to the Play Console : browse to \"Release Management\" > \"App Releases\" > \"Internal test track\" > \"Manage\" \"Create Release\" and upload the signed APK, set the version to match the tag (for example: 1.2.1339 ) then \"Review\" and the build will be immediately available to the core team Continue the \"Distributing...\" instructions","title":"In Case of Emergency (Release)"},{"location":"releases/#distributing-builds-through-play-store-internal-alpha","text":"all builds must be manually uploaded from bitrise to Play Store Console as an artifact aka \"New Release\" in the \"Preparing\" instructions above Browse to App Releases in Play Console Browse to the \"Internal test track\" (this release should already be uploaded and available to the core Lockbox team) Promote the release to the (internal still) Alpha channel using the \"Promote to Alpha\" button, complete the questions","title":"Distributing Builds through Play Store (Internal, Alpha)"},{"location":"releases/#distributing-through-the-app-store-production","text":"Contact release management... NOTE: brand new apps may take 1 or more hours to appear in the Play Store whereas existing app (updates) can appear within minutes. Schedule accordingly!","title":"Distributing through the App Store (Production)"},{"location":"releases/#updating-the-version","text":"Once a version has been merged or released, the major app version should be increased Update the versionName value (and versionCode if applicable) in app/build.gradle Also update the value in the list_cell_setting_appversion.xml layout to the exact same version","title":"Updating the version"},{"location":"test-plan/","text":"Test Plan Test plan for Firefox Lockbox for Android Overview Firefox Lockbox for Android is a new mobile app developed with a pre-defined set of P1 \"must have\" requirements and a target release at the beginning of February 2019 in the Google Play Store. Mozilla Product Integrity provides embedded QA to work with the team throughout the bi-weekly sprints allowing for ongoing testing and feedback, issue triage, and continuous test plan development and end-to-end regression testing in order to accommodate a quick release schedule. Ownership Product Integrity: Andrei Bodea, Bogdan Surd Product Manager: Sandy Sage Engineering Manager: Devin Reams Engineering Leads: Sasha Heinen, James Hugman, Matt Miller, Elise Richards Entry Criteria PI has access to all product documentation, designs, code The Android app code is available on GitHub and builds: locally via Android Studio (Branch and Release) on device via bitrise.io (Branch and Release) on device via Play Store (Release) Exit Criteria All test suites against P1 \"must have\" features have performed All bugs related to the P1 \"must have\" features have been triaged All bugs resolved fixed have been verified Test Matrix Devices to be tested: TBD Major operating system versions to be tested: Minimum: API 23 Target: API 28 Test Suites Documented in TestRail: https://testrail.stage.mozaws.net/index.php?/suites/view/3060&group_by=cases:section_id&group_order=asc (internal Mozilla tool) Performed twice-weekly Covers all P1 \"must have\" Requirements (internal Mozilla document) 01 Sign in to Sync 02 Onboarding 03 Access saved entries 04 No entries support 05 Biometrics to lock/unlock 06 View entry 07 Copy / paste retrieval 08 View password 09 Autofill 10 Account management 11 Browser setting 12 Support 13 Telemetry Accessibility There are a number of best practices and accessibility features available to Android developers and we intend to build and test for. We've documented the tools and techniques available to test accessibility and ask that every pull request consider these before merging so as to not accumulate \"debt\" during development but also test all of the following at certain intervals in the project: 1. TalkBack support The reading of on-screen interface items and objects. Testing for: All on-screen navigation and button titles are read All on-screen alerts and popovers (interrupting the interface) are read All labels and text elements on screen are read Interaction elements like input boxes and filters have meaningful instructions Links to open websites are clearly indicated and read Swiping left/right to select next/previous elements works usefully Interface scrolling is available where needed 2. User interface design The interface is legible and tappable by designing and testing for: adequate color contrasts (e.g.: no light text on light background) button and input sizes (e.g.: large enough to tap into easily and consistently) text sizes follow system adjustment (i.e. respect \"Larger Text\" setting) Out of Scope Internal metrics/analytics review and testing (see metrics.md ) Internal security review (performed separately)","title":"Test Plan"},{"location":"test-plan/#test-plan","text":"Test plan for Firefox Lockbox for Android","title":"Test Plan"},{"location":"test-plan/#overview","text":"Firefox Lockbox for Android is a new mobile app developed with a pre-defined set of P1 \"must have\" requirements and a target release at the beginning of February 2019 in the Google Play Store. Mozilla Product Integrity provides embedded QA to work with the team throughout the bi-weekly sprints allowing for ongoing testing and feedback, issue triage, and continuous test plan development and end-to-end regression testing in order to accommodate a quick release schedule.","title":"Overview"},{"location":"test-plan/#ownership","text":"Product Integrity: Andrei Bodea, Bogdan Surd Product Manager: Sandy Sage Engineering Manager: Devin Reams Engineering Leads: Sasha Heinen, James Hugman, Matt Miller, Elise Richards","title":"Ownership"},{"location":"test-plan/#entry-criteria","text":"PI has access to all product documentation, designs, code The Android app code is available on GitHub and builds: locally via Android Studio (Branch and Release) on device via bitrise.io (Branch and Release) on device via Play Store (Release)","title":"Entry Criteria"},{"location":"test-plan/#exit-criteria","text":"All test suites against P1 \"must have\" features have performed All bugs related to the P1 \"must have\" features have been triaged All bugs resolved fixed have been verified","title":"Exit Criteria"},{"location":"test-plan/#test-matrix","text":"Devices to be tested: TBD Major operating system versions to be tested: Minimum: API 23 Target: API 28","title":"Test Matrix"},{"location":"test-plan/#test-suites","text":"Documented in TestRail: https://testrail.stage.mozaws.net/index.php?/suites/view/3060&group_by=cases:section_id&group_order=asc (internal Mozilla tool) Performed twice-weekly Covers all P1 \"must have\" Requirements (internal Mozilla document) 01 Sign in to Sync 02 Onboarding 03 Access saved entries 04 No entries support 05 Biometrics to lock/unlock 06 View entry 07 Copy / paste retrieval 08 View password 09 Autofill 10 Account management 11 Browser setting 12 Support 13 Telemetry","title":"Test Suites"},{"location":"test-plan/#accessibility","text":"There are a number of best practices and accessibility features available to Android developers and we intend to build and test for. We've documented the tools and techniques available to test accessibility and ask that every pull request consider these before merging so as to not accumulate \"debt\" during development but also test all of the following at certain intervals in the project:","title":"Accessibility"},{"location":"test-plan/#1-talkback-support","text":"The reading of on-screen interface items and objects. Testing for: All on-screen navigation and button titles are read All on-screen alerts and popovers (interrupting the interface) are read All labels and text elements on screen are read Interaction elements like input boxes and filters have meaningful instructions Links to open websites are clearly indicated and read Swiping left/right to select next/previous elements works usefully Interface scrolling is available where needed","title":"1. TalkBack support"},{"location":"test-plan/#2-user-interface-design","text":"The interface is legible and tappable by designing and testing for: adequate color contrasts (e.g.: no light text on light background) button and input sizes (e.g.: large enough to tap into easily and consistently) text sizes follow system adjustment (i.e. respect \"Larger Text\" setting)","title":"2. User interface design"},{"location":"test-plan/#out-of-scope","text":"Internal metrics/analytics review and testing (see metrics.md ) Internal security review (performed separately)","title":"Out of Scope"},{"location":"architecture/autofill/","text":"Autofill Framework Interaction Currently, Lockbox for Android only supports the Autofill Framework as provided by Google. Support for this framework is not universal among apps in the Play store, so autofill will not always behave as expected. Enumerated below are the simple strategies we use and their priorities in determining which views should receive autofill suggestions with Username and Password credentials. Heuristics for determining autofill-able views in native applications Using the autofillHints attribute on EditText views Using the text and hint attributes on EditText views Assuming that a TextView with the relevant autofillHints , text , or hint attributes immediately followed by an EditText view, should autofill the EditText","title":"Autofill"},{"location":"architecture/autofill/#autofill-framework-interaction","text":"Currently, Lockbox for Android only supports the Autofill Framework as provided by Google. Support for this framework is not universal among apps in the Play store, so autofill will not always behave as expected. Enumerated below are the simple strategies we use and their priorities in determining which views should receive autofill suggestions with Username and Password credentials.","title":"Autofill Framework Interaction"},{"location":"architecture/autofill/#heuristics-for-determining-autofill-able-views-in-native-applications","text":"Using the autofillHints attribute on EditText views Using the text and hint attributes on EditText views Assuming that a TextView with the relevant autofillHints , text , or hint attributes immediately followed by an EditText view, should autofill the EditText","title":"Heuristics for determining autofill-able views in native applications"},{"location":"architecture/flux/","text":"Firefox Lockbox for Android Architecture RxKotlin Firefox Lockbox for Android makes extensive use of RxKotlin, an implementation of the Observable pattern from ReactiveX. More information and many marble diagrams can be found in the ReactiveX documentation . The rest of this document relies on a basic understanding of the reader of the ReactiveX-style Observer implementation. Their intro document is a good starting point . Flux Architecture Pattern In short, Flux architecture design maintains a unidirectional data flow, in which a global Dispatcher receives Actions & dispatches them to appropriate Stores. The Stores, in turn, process data & provide the source of truth for the Views. As users interact with the Views, any updates are made via a dispatched Action and the cycle begins again. See this flux architecture writeup for more details on the original Flux architecture scheme. Lockbox implements a modified version of the described architecture (LockFlux), keeping in mind that the original implementation ignores asynchronous work. In this implementation, all asynchronous work is handled by the Stores as they reduce actions and state updates to their observable state. Memory Management The five major components of this architecture ( View , Presenter , Store , Dispatcher , and Action ) have distinct lifecycle management based on their functions. View / Presenter pairs are allocated and de-allocated as views get displayed or hidden in turn. Store s and the Dispatcher are global singleton objects, meaning that they get lazy-loaded by the application as their shared members get accessed by the Presenter s for view configuration or dispatching. Action s get deallocated as soon as they reach the end observer for their intended function. View/Presenter All views are bound to a presenter. In this separation, the presenter is responsible for all business logic, and the view is abstracted to a simple interface. The view is responsible for UI-specific configuration and passing user input to its presenter for handling. This allows any complex view-related configuration to be abstracted when dealing with business logic changes, and vice versa. In the current implementation of LockFlux on Android, all View s are composed of Fragments, not Activities. Situations requiring an Activity to be added to the application will be reviewed on a case-to-case basis. Actions Actions are tiny enum s or sealed class es that contain declarative language about either the triggering user action or the update request for a given Store . Actions can also be used to pass objects (item IDs, string resources, Telemetry events) between fragments. Dispatcher The dispatcher class is the simplest in the application; it provides an Action -accepting method as a wrapper for the PublishSubject<Action> that publishes all dispatched actions to interested Stores : class Dispatcher { companion object { val shared = Dispatcher() } private val actionSubject = PublishSubject.create<Action>() val register: Observable<Action> = this.actionSubject fun dispatch(action: Action) { this.actionSubject.onNext(action) } } Store Stores provide an opaque wrapper around system storage or simple Replay- /Publish- Subject s for the purposes of data access and view configuration. They selectively register with the Dispatcher for the Action s that they care about for updating state. Stores also perform any asynchronous tasks that relate to the updating of their local state. The Action s dispatched by Presenter s are completely decoupled from observed Store state, removing the need for callback configurations. It's important to note that there is no concept of ordering; all Action s will be delivered to Store s in realtime as they are dispatched. View Routing The special case in this scenario is view routing. To handle the view-changing component of the architecture, there is a RouteStore observed by a RoutePresenter that rides along on the back of a RootActivity . This \u201ccontaining\u201d activity is not displayed to the user; rather, it performs the role of listening for navigation-specific Action s & performing the necessary top-level fragment swapping and back stack manipulation. Routing logic lives entirely separately from individual view configuration logic, allowing for modular view manipulation and easy testing. Benefits of Flux Close readers will note that this document borrows heavily from a similar one in our iOS application . The shared Flux pattern and reactive libraries allow us to \"borrow\" view-presentation logic from iOS as we move forward on Android. Additionally, the separation of high-level view manipulation from view allows us to iterate quickly on implementation details and design feedback without implications for unrelated parts of the app.","title":"Flux Architecture"},{"location":"architecture/flux/#firefox-lockbox-for-android-architecture","text":"","title":"Firefox Lockbox for Android Architecture"},{"location":"architecture/flux/#rxkotlin","text":"Firefox Lockbox for Android makes extensive use of RxKotlin, an implementation of the Observable pattern from ReactiveX. More information and many marble diagrams can be found in the ReactiveX documentation . The rest of this document relies on a basic understanding of the reader of the ReactiveX-style Observer implementation. Their intro document is a good starting point .","title":"RxKotlin"},{"location":"architecture/flux/#flux","text":"","title":"Flux"},{"location":"architecture/flux/#architecture-pattern","text":"In short, Flux architecture design maintains a unidirectional data flow, in which a global Dispatcher receives Actions & dispatches them to appropriate Stores. The Stores, in turn, process data & provide the source of truth for the Views. As users interact with the Views, any updates are made via a dispatched Action and the cycle begins again. See this flux architecture writeup for more details on the original Flux architecture scheme. Lockbox implements a modified version of the described architecture (LockFlux), keeping in mind that the original implementation ignores asynchronous work. In this implementation, all asynchronous work is handled by the Stores as they reduce actions and state updates to their observable state.","title":"Architecture Pattern"},{"location":"architecture/flux/#memory-management","text":"The five major components of this architecture ( View , Presenter , Store , Dispatcher , and Action ) have distinct lifecycle management based on their functions. View / Presenter pairs are allocated and de-allocated as views get displayed or hidden in turn. Store s and the Dispatcher are global singleton objects, meaning that they get lazy-loaded by the application as their shared members get accessed by the Presenter s for view configuration or dispatching. Action s get deallocated as soon as they reach the end observer for their intended function.","title":"Memory Management"},{"location":"architecture/flux/#viewpresenter","text":"All views are bound to a presenter. In this separation, the presenter is responsible for all business logic, and the view is abstracted to a simple interface. The view is responsible for UI-specific configuration and passing user input to its presenter for handling. This allows any complex view-related configuration to be abstracted when dealing with business logic changes, and vice versa. In the current implementation of LockFlux on Android, all View s are composed of Fragments, not Activities. Situations requiring an Activity to be added to the application will be reviewed on a case-to-case basis.","title":"View/Presenter"},{"location":"architecture/flux/#actions","text":"Actions are tiny enum s or sealed class es that contain declarative language about either the triggering user action or the update request for a given Store . Actions can also be used to pass objects (item IDs, string resources, Telemetry events) between fragments.","title":"Actions"},{"location":"architecture/flux/#dispatcher","text":"The dispatcher class is the simplest in the application; it provides an Action -accepting method as a wrapper for the PublishSubject<Action> that publishes all dispatched actions to interested Stores : class Dispatcher { companion object { val shared = Dispatcher() } private val actionSubject = PublishSubject.create<Action>() val register: Observable<Action> = this.actionSubject fun dispatch(action: Action) { this.actionSubject.onNext(action) } }","title":"Dispatcher"},{"location":"architecture/flux/#store","text":"Stores provide an opaque wrapper around system storage or simple Replay- /Publish- Subject s for the purposes of data access and view configuration. They selectively register with the Dispatcher for the Action s that they care about for updating state. Stores also perform any asynchronous tasks that relate to the updating of their local state. The Action s dispatched by Presenter s are completely decoupled from observed Store state, removing the need for callback configurations. It's important to note that there is no concept of ordering; all Action s will be delivered to Store s in realtime as they are dispatched.","title":"Store"},{"location":"architecture/flux/#view-routing","text":"The special case in this scenario is view routing. To handle the view-changing component of the architecture, there is a RouteStore observed by a RoutePresenter that rides along on the back of a RootActivity . This \u201ccontaining\u201d activity is not displayed to the user; rather, it performs the role of listening for navigation-specific Action s & performing the necessary top-level fragment swapping and back stack manipulation. Routing logic lives entirely separately from individual view configuration logic, allowing for modular view manipulation and easy testing.","title":"View Routing"},{"location":"architecture/flux/#benefits-of-flux","text":"Close readers will note that this document borrows heavily from a similar one in our iOS application . The shared Flux pattern and reactive libraries allow us to \"borrow\" view-presentation logic from iOS as we move forward on Android. Additionally, the separation of high-level view manipulation from view allows us to iterate quickly on implementation details and design feedback without implications for unrelated parts of the app.","title":"Benefits of Flux"},{"location":"architecture/sec-apis/","text":"On Using Keys and Biometrics Below are some findings on using a couple of security features in Android: AndroidKeyStore Biometrics Device locks Using AndroidKeyStore The AndroidKeyStore is an implementation of the Java Cryptography Architecture (JCA) 's KeyStore service to manage application-specific cryptographic keys. Such keys can be created or imported with an associated label, then an opaque Key class obtained from that label to use for cryptographic operations. However, they cannot be exported. The remainder here focuses on creating rather than import. Obtaining this Keystore is done using the static method Keystore.getIstance() and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider. New keys are created using an instance of KeyGenerator (or KeyPairGenerator ), again specifying \"AndroidKeyStore\" as the SPI provider. When creating a new key, several properties can be applied via KeyGenParameterSpec , including: key size (in bits) encryption block modes (e.g., GCM ) encryption padding (e.g., NONE ) require authentication duration until next authentication (in seconds) Once set, these properties cannot be changed without first deleting then re-importing/-creating the key. If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for every use, it can only be done if the user has at least one fingerprint enrolled. Keys in the AndroidKeyStore are stored on the device until one of the following happens: The app deletes its entry from the KeyStore The app's data storage (not data cache) is cleared The app is uninstalled Keys with user authentication required are invalided and cannot be used if any of the following happen: The device is hard reset The security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None) Further, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen: A new fingerprint is enrolled All fingerprints are unenrolled Existing Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g., .getSecretKey() ). Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return null ; this is true even for PublicKeys. the \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment. If the key requires authentication, a UserNotAuthenticatedException is thrown; if the key no longer valid (as above), a KeyPermanentlyInvalidatedException is thrown. Using KeyguardManager The KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device. It can only be obtained from a Context (e.g., Activity ). The most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked. Both are boolean values; it is not possible to determine which method of lock is configured. In addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of createConfirmDeviceCredentialIntent() ; if no \"strong\" security lock is configured, this method returns null . The Intent is created with optional title and description, then dispatched via startActivityForResult() to trigger the device prompts. Applications receive either RESULT_OK (if successfully unlocked) or RESULT_CANCELED (device prompt is dismissed) via the overridden method onActivityResult() . It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received. Using FingerprintManager NOTE: This API is marked as deprecated as of API 28 (Android Pie) and replaced with BiometricPrompt . The FingerprintManager is a system service used to interact with a device's fingerprint hardware. This was added in API 23, and is now deprecated as of API 28. As with KeyguardManager it can only be obtained from a Context (e.g., Activity ). It also requires the USE_FINGERPRINT or USE_BIOMETRIC (added in API 28) permission in the app's manifest. There are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled. Engaging the fingerprint reader is done by calling authenticate() . Before doing so, the app must provide a FingerprintManager.CryptoObject and a FingerprintManager.AuthenticationCallback . This method returns immediately; further interaction happens via the passed-in AuthenticationCallback . An optional CancellationSignal can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button). This object only engages the hardware; it does not display anything to the user itself. The app is responsible for managing a view regarding the fingerprint reading operations. Once the reader has succeeded or errored, it is no longer valid; a new instance must be obtained. About the CryptoObject The required CryptoObject wraps a Cipher , Mac or Signature object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used. About the AuthenticationCallback The required AuthenticationCallback is where events from fingerprint reader attempts are dispatched. Subclasses need only override the event methods they are interested in. On success onAuthenticationSuccessful() is called with the original CryptoObject wrapped in a AuthenticationResult . If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use). A fingerprint read failure is notified via onAuthenticaitonFailed() , such as a unrecognized print. If there is some other temporary failure (e.g., dirty reader), onAuthenticationHelp() is called with the relevant status code and a (device locale appropriate) user-directed help message. Permanent errors are notified via onAuthenticationError() , with the relevant status code and (device locale appropriate) user-directed error message. Using BiometricPrompt The BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog. This class is introduced in API 28 to replace FingerprintManager. The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader). To create a BiometricPrmpt , a BiometricPrompt.Builder is created (with an appropriate Context ) and configured. The app can set a title, subtitle, description, and \"cancel\" button behavior. Once created, the app calls authenticate() (just like with FingerprintManager ). The hardware-engagement behavior is nearly identical to FingerprintManager ; the app is notified of events via an instance of BiometricPrompt.AuthenticationCallback (which has the exact same methods as FingerprintManager.AuthenticationCallback ), can be canceled via a CancellationSignal , and operates on a CryptoObject . The biggest differences are: The CryptoObject is optional The app must explicitly provide an Executor where events are dispatched (this can be Context.mainExecutor ) The app no longer manages any view to interact with the user.","title":"Using Keys and Biometrics"},{"location":"architecture/sec-apis/#on-using-keys-and-biometrics","text":"Below are some findings on using a couple of security features in Android: AndroidKeyStore Biometrics Device locks","title":"On Using Keys and Biometrics"},{"location":"architecture/sec-apis/#using-androidkeystore","text":"The AndroidKeyStore is an implementation of the Java Cryptography Architecture (JCA) 's KeyStore service to manage application-specific cryptographic keys. Such keys can be created or imported with an associated label, then an opaque Key class obtained from that label to use for cryptographic operations. However, they cannot be exported. The remainder here focuses on creating rather than import. Obtaining this Keystore is done using the static method Keystore.getIstance() and specifying the \"AndroidKeyStore\" Service Provider Interface (SPI) provider. New keys are created using an instance of KeyGenerator (or KeyPairGenerator ), again specifying \"AndroidKeyStore\" as the SPI provider. When creating a new key, several properties can be applied via KeyGenParameterSpec , including: key size (in bits) encryption block modes (e.g., GCM ) encryption padding (e.g., NONE ) require authentication duration until next authentication (in seconds) Once set, these properties cannot be changed without first deleting then re-importing/-creating the key. If the key creation requests some user authentication is required, it can only be done if the device has a security lock set (e.g., Pattern/PIN/Password); if user authentication is required for every use, it can only be done if the user has at least one fingerprint enrolled. Keys in the AndroidKeyStore are stored on the device until one of the following happens: The app deletes its entry from the KeyStore The app's data storage (not data cache) is cleared The app is uninstalled Keys with user authentication required are invalided and cannot be used if any of the following happen: The device is hard reset The security lock is disabled (e.g., changed from Pattern/PIN/Password to Swipe or None) Further, \"authenticate every use\" keys are invalided and cannot be used if any of the following happen: A new fingerprint is enrolled All fingerprints are unenrolled Existing Key objects (secret, private, public, and even certificates) are obtained using the Keystore instance's typical methods (e.g., .getSecretKey() ). Note that all of the methods on the Key object that would export the value (e.g., getEncoded()) either throw exception or return null ; this is true even for PublicKeys. the \"Java Standard\" Cipher/Mac/Signature classes are used in Android as they are in any other Java/Kotlin environment. If the key requires authentication, a UserNotAuthenticatedException is thrown; if the key no longer valid (as above), a KeyPermanentlyInvalidatedException is thrown.","title":"Using AndroidKeyStore"},{"location":"architecture/sec-apis/#using-keyguardmanager","text":"The KeyguardManager is a system service that originally used to lock/unlock the keyboard, but has since expanded to lock/unlock the user's device. It can only be obtained from a Context (e.g., Activity ). The most interesting methods here are those that determine if a \"strong\" security lock (Pattern/PIN/Password) is configured and if the device is currently locked. Both are boolean values; it is not possible to determine which method of lock is configured. In addition, the KeyguardManager can be used to prompt the user to enter their Pattern/PIN/Password by way of createConfirmDeviceCredentialIntent() ; if no \"strong\" security lock is configured, this method returns null . The Intent is created with optional title and description, then dispatched via startActivityForResult() to trigger the device prompts. Applications receive either RESULT_OK (if successfully unlocked) or RESULT_CANCELED (device prompt is dismissed) via the overridden method onActivityResult() . It is important to note that dispatching and monitoring is best done from a long-running Activity, such as the MainActivity, or the result is never received.","title":"Using KeyguardManager"},{"location":"architecture/sec-apis/#using-fingerprintmanager","text":"NOTE: This API is marked as deprecated as of API 28 (Android Pie) and replaced with BiometricPrompt . The FingerprintManager is a system service used to interact with a device's fingerprint hardware. This was added in API 23, and is now deprecated as of API 28. As with KeyguardManager it can only be obtained from a Context (e.g., Activity ). It also requires the USE_FINGERPRINT or USE_BIOMETRIC (added in API 28) permission in the app's manifest. There are methods to determine if fingerprint authentication is possible; detecting if hardware exists and there is at least one fingerprint enrolled. Engaging the fingerprint reader is done by calling authenticate() . Before doing so, the app must provide a FingerprintManager.CryptoObject and a FingerprintManager.AuthenticationCallback . This method returns immediately; further interaction happens via the passed-in AuthenticationCallback . An optional CancellationSignal can be provided to disengage the fingerprint hardware out-of-band (e.g., from the user clicking a \"Cancel\" button). This object only engages the hardware; it does not display anything to the user itself. The app is responsible for managing a view regarding the fingerprint reading operations. Once the reader has succeeded or errored, it is no longer valid; a new instance must be obtained.","title":"Using FingerprintManager"},{"location":"architecture/sec-apis/#about-the-cryptoobject","text":"The required CryptoObject wraps a Cipher , Mac or Signature object, ready and initialized with the desired key. the scanner is engaged regardless of the key's authentication requirements, so even keys without any requirements can be used.","title":"About the CryptoObject"},{"location":"architecture/sec-apis/#about-the-authenticationcallback","text":"The required AuthenticationCallback is where events from fingerprint reader attempts are dispatched. Subclasses need only override the event methods they are interested in. On success onAuthenticationSuccessful() is called with the original CryptoObject wrapped in a AuthenticationResult . If the key required authentication, it is now useable within this method's bounds (and only now if authentication is required on every use). A fingerprint read failure is notified via onAuthenticaitonFailed() , such as a unrecognized print. If there is some other temporary failure (e.g., dirty reader), onAuthenticationHelp() is called with the relevant status code and a (device locale appropriate) user-directed help message. Permanent errors are notified via onAuthenticationError() , with the relevant status code and (device locale appropriate) user-directed error message.","title":"About the AuthenticationCallback"},{"location":"architecture/sec-apis/#using-biometricprompt","text":"The BiometricPrompt is a class used to engage a device's biometrics hardware using a system-provided dialog. This class is introduced in API 28 to replace FingerprintManager. The intent is to support not only fingerprint readers, but also facial recognition; it also handles hardware variations, such as in-screen fingerprint readers (e.g., display a user prompt that indicates the on-screen boundaries of the reader). To create a BiometricPrmpt , a BiometricPrompt.Builder is created (with an appropriate Context ) and configured. The app can set a title, subtitle, description, and \"cancel\" button behavior. Once created, the app calls authenticate() (just like with FingerprintManager ). The hardware-engagement behavior is nearly identical to FingerprintManager ; the app is notified of events via an instance of BiometricPrompt.AuthenticationCallback (which has the exact same methods as FingerprintManager.AuthenticationCallback ), can be canceled via a CancellationSignal , and operates on a CryptoObject . The biggest differences are: The CryptoObject is optional The app must explicitly provide an Executor where events are dispatched (this can be Context.mainExecutor ) The app no longer manages any view to interact with the user.","title":"Using BiometricPrompt"}]}